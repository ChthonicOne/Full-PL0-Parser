// Team name:  Compiler Builder 11//// Emily ["Mel"] Pelchat// Hunter Pierce// Jacob Hazelbaker// Jessica ["Kika"] Wingert#include <stdio.h>#include <stdlib.h>#define MAX_STACK_HEIGHT 2000#define MAX_CODE_LENGTH 500#define MAX_LEXI_LEVELS 3typedef struct{ int op; int l; int m;}instr;/// global variables ftwchar *opcodes[] = {"", "LIT", "OPR", "LOD", "STO", "CAL", "INC", "JMP", "JPC", "SIO"}; //stolen from Hunterchar *opcodesSIO[] = {"OUT", "INP", "HLT"};char *opcodesOPR[] = {"RET", "NEG", "ADD", "SUB", "MUL", "DIV", "ODD", "MOD", "EQL", "NEQ", "LSS", "LEQ", "GTR", "GEQ"};int bp = 1;int sp = 0;int pc = 0;instr ir;int stack[MAX_STACK_HEIGHT+1];instr code[MAX_CODE_LENGTH];int codeSize=-1;FILE *fp;///FILE *ofp;///void write_Stack(int bp, int sp);void printCode();void fetchCycle();void executeCycle();void printHeading();///void printStateF();void printStateE();void printStack();///void printStackAR();int halt();int base(int level, int b);int main(int argc, char * argv[]){ stack[1] = 0; stack[2] = 0; stack[3] = 0;  /*** ///open files fp = fopen("test.txt", "r"); ///ofp = fopen("testout.txt", "w"); if(fp==NULL) //|| ofp==NULL)      printf("error opening file\n");      ***/     fp = fopen(argv[1], "r");       // open the input file    ///ofp = fopen("trace.txt", "w");  // open the output file if(fp==NULL) {        printf("Error opening input file %s\nExiting Program ...\n", argv[1]);        return -1;    }    ///if (ofp == NULL) {       /// printf("Error opening output file\nExiting Program ...\n");        ///return -1;   ///read fp into code[]   int lines;      //num lines in fp while(!feof(fp)){      for(lines=0; lines<MAX_CODE_LENGTH; lines++){         fscanf(fp, "%d %d %d", &code[lines].op, &code[lines].l, &code[lines].m);         if(feof(fp)){            codeSize = lines+1;   /// lines is now also equal to instruction number            break;         }      }      ///print pl/0 code      printf("PL/0 code:\n\n");  printCode(); }   ///print execution   printHeading();   do{    fetchCycle();    //printStateF();    executeCycle();    printStateE();    //write_Stack(bp, sp);    printStack();   } while(!halt()); fclose(fp); ///fclose(ofp); return 0;}void write_Stack(int bp, int sp){    // TO DO - Write the contents of the stack to output_file    int i;    if (bp > 1) {        write_Stack(stack[bp+2], bp-1);        if (bp<sp)            printf("| ");        for (i = bp; i <= sp; i++) {            printf("%d ", stack[i]);        }        printf("\n");    }    else {        for (i=bp; i<=sp; i++)        {            printf("%d ", stack[i]);        }    }    printf("\n");}void printCode(){  int i;   for(i=0; i<codeSize-1; i++){   switch(code[i].op){    /// LIT __  M    case 1:     printf("%3d  %s %9d\n", i, opcodes[code[i].op], code[i].m);     break;    /// OPR    case 2:       if(code[i].m == 0)                  printf("%3d  %s\n", i, opcodesOPR[code[i].m]);     else                  printf("%3d  %s%5d%5d\n", i, opcodesOPR[code[i].m], code[i].l, code[i].m);     break;     //switch(ir.m){      /// RET __ __      //case 0:       //printf("%3d  %s\n", i, opcodesOPR[code[i].m]);      ///     //}    /// LOD L M    case 3:     printf("%3d  %s%5d%5d\n", i, opcodes[code[i].op], code[i].l, code[i].m);     break;    /// STO L M    case 4:     printf("%3d  %s%5d%5d\n", i, opcodes[code[i].op], code[i].l, code[i].m);     break;    /// CAL L M    case 5:     printf("%3d  %s%5d%5d\n", i, opcodes[code[i].op], code[i].l, code[i].m);     break;    /// INC __ M    case 6:     printf("%3d  %s %9d\n", i, opcodes[code[i].op], code[i].m);     break;    /// JMP __ M    case 7:     printf("%3d  %s %9d\n", i, opcodes[code[i].op], code[i].m);     break;    ///??????????? JPC __ M ?????????    case 8:     printf("%3d  %s %9d\n", i, opcodes[code[i].op], code[i].m);     break;    /// SIO    case 9:     if(code[i].m == 2)      printf("%3d  %s\n", i, opcodesSIO[code[i].m]);     else                  printf("%3d  %s %9d\n", i, opcodesSIO[code[i].m], code[i].m);     break;    default:     ;   }  }  printf("\n");   /*     if (code[i].op == 2)       printf("%3d  %s%5d%5d\n", i, opcodesOPR[code[i].m], code[i].l, code[i].m);       if (code[i].op == 9)       printf("%3d  %s\n", i, opcodesSIO[code[i].m]);       else         printf("%3d  %s%5d%5d\n", i, opcodes[code[i].op], code[i].l, code[i].m);   }   printf("\n");*/}void printHeading(){ printf("Execution:\n"); printf("                      pc   bp   sp   stack\n"); printf("%24d%5d%5d  \n", pc, bp, sp);}///print state of machine after fetch cyclevoid printStateF(){   switch(ir.op){      case 2:         printf("%3d  %s%5d%5d\n", pc-1, opcodesOPR[ir.m], ir.l, ir.m);      case 9:         switch(ir.m){            case 2:               printf("%3d  %s\n", pc-1, opcodesSIO[ir.m]);            default:               printf("%3d  %s%5d%5d\n", pc-1, opcodesSIO[ir.m], ir.l, ir.m);         }      default:         ; //printf("%3d  %s%5d%5d", pc-1, opcodes[ir.op], ir.l, ir.m);   }}/// print state of machine after execute cyclevoid printStateE(){   if(sp==0 || bp==1)      printf("%6d%5d%5d", pc, bp, sp);   else      printf("%6d%5d%5d", pc, bp, sp);}void printStack(){ int i, bp_copy=bp; printf("   ");   /*if(sp==0){   } else if(bp_copy==1){      for (i=1; i<=sp; i++)         printf("%d ", stack[i]); } for (i=1; i<=bp_copy; i++)      printf("%d ", stack[i]); if(bp_copy>1){      if(bp_copy<sp){         printf(" | ");      for (i=bp_copy; i<=sp; i++)         printf("%d ", stack[i]);      } }//      if(bp==1)//         break;*/    if(bp_copy==1 && sp!=0){      for(i=1; i<=sp; i++)        printf("%d ", stack[i]);    }   else if(bp_copy>1){      for(i=1; i<bp_copy; i++)        printf("%d ", stack[i]);      if(bp_copy<sp)         printf("| ");      for(i=bp_copy; i<=sp; i++)         printf("%d ", stack[i]); } printf("\n");}void printStackAR(){ int i = 1; printf("  "); for (i=2; i<=sp; i++)  printf("%2d", stack[i]); printf(" |");}void fetchCycle(){   ir = code[pc];   pc++;   //printf("%d fetched\n", ir.op);}void executeCycle(){ switch(ir.op){  // 01 LIT 0 M  push m onto stack  case 1:      //printf("executing LIT\n");            printf("%3d  %s %9d", pc-1, opcodes[ir.op], ir.m);            sp = sp + 1;   stack[sp] = ir.m;   break;  // 02 OPR 0 M  case 2:            //printf("executing OPR\n");            //printf("%3d  %s%5d%5d\n", pc-1, opcodesOPR[ir.m], ir.l, ir.m);            printf("%3d  %s  \t  ", pc-1, opcodesOPR[ir.m]);            switch(ir.m){      /// RET            case 0:               sp = bp-1;               pc = stack[sp+4]; //4               bp = stack[sp+3]; //3               break;            /// NEG            case 1:               stack[sp] = -stack[sp];               break;            ///ADD            case 2:               sp = sp-1;               stack[sp] = stack[sp] + stack[sp+1];               break;            /// SUB            case 3:               sp = sp-1;               stack[sp] = stack[sp] - stack[sp+1];               break;            /// MUL            case 4:               sp = sp-1;               stack[sp] = stack[sp] * stack[sp+1];               break;            /// DIV            case 5:               sp = sp-1;               stack[sp] = stack[sp] / stack[sp+1];               break;            /// ODD            case 6:               stack[sp] = stack[sp] & 1;               break;            /// MOD            case 7:               sp = sp-1;               stack[sp] = stack[sp] % stack[sp+1];               break;            /// EQL            case 8:               sp = sp-1;               stack[sp] = stack[sp] == stack[sp+1];               break;            /// NEQ            case 9:               sp = sp-1;               stack[sp] = stack[sp] != stack[sp+1];               break;            /// LSS            case 10:               sp = sp-1;               stack[sp] = stack[sp] < stack[sp+1];               break;            /// LEQ            case 11:               sp = sp-1;               stack[sp] = stack[sp] <= stack[sp+1];               break;            /// GTR            case 12:               sp = sp-1;               stack[sp] = stack[sp] > stack[sp+1];               break;            /// GEQ            case 13:               sp = sp-1;               stack[sp] = stack[sp] >= stack[sp+1];               break;            default:               printf("error executing OPR\n");     }   break;  // 03 LOD L M  push stack value of offset M in frame L levels down  case 3:            //printf("executing LOD\n");            printf("%3d  %s%5d%5d", pc-1, opcodes[ir.op], ir.l, ir.m);   sp = sp + 1;   stack[sp] = stack[base(ir.l, bp) + ir.m];   break;  // 04 STO L M  pop stack, insert val at offset M in frame L levels down  case 4:            //printf("executing STO\n");            printf("%3d  %s%5d%5d", pc-1, opcodes[ir.op], ir.l, ir.m);   stack[base(ir.l, bp) + ir.m] = stack[sp];   sp--;   //if(sp>0)    //sp--;   break;  // 05 CAL L M Call procedure at M  case 5:            //printf("executing CAL\n");            printf("%3d  %s%5d%5d", pc-1, opcodes[ir.op], ir.l, ir.m);            //printStackAR();   stack[sp+1] = 0;       // return value   stack[sp+2] = base(ir.l, bp);          //static link   stack[sp+3] = bp;       //dynamic link   stack[sp+4] = pc;       // return address   bp = sp+1;   pc = ir.m;   //printStack();   break;  // 06 INC 0 M  allocate m locals on stack  case 6:            //printf("executing INC\n");            printf("%3d  %s %9d", pc-1, opcodes[ir.op], ir.m);          /*if(sp == 0){        // What is this for?            sp = ir.m + 1;      // We add M to 0, and then add 1     sp--;               // only to subtract 1 after? This makes no sense.            }            else */            sp = sp + ir.m;     // Just add sp to M and be done with it. Both if branches ended up doing exactly the same thing.            break;  // 07 JMP 0 M  jump to M  case 7:            //printf("executing JMP\n");            //printf("%10d", ir.m);            printf("%3d  %s %9d", pc-1, opcodes[ir.op], ir.m);   pc = ir.m;      //NOOOO! Not sp+ This is not opr 6, it's 7... This is Jump. You jump to M, not to M+sp No wonder we seg faulted!   break;  // 08 JPC   pop stack, jump to m  case 8:            //printf("executing JPC\n");            printf("%3d  %s %9d", pc-1, opcodes[ir.op], ir.m);   if(stack[sp] == 0)    pc = ir.m;   sp = sp-1;   break;  // 09 SIO  case 9:            //printf("executing SIO\n");            //printf("executing SIO\n");            //printf("%3d  %s%5d%5d\n", pc-1, opcodesSIO[ir.m], ir.l, ir.m);   switch(ir.m){    // pop stack    case 0:     printf("%3d  %s %9d", pc-1, opcodesSIO[ir.m], ir.m);     printf("popped stack val: %d\n", stack[sp]);     sp = sp-1;     break;    // push user input    case 1:     printf("%3d  %s %9d", pc-1, opcodesSIO[ir.m], ir.m);     sp = sp+1;     scanf("%d", &(stack[sp]));     break;    // halt    case 2:     printf("%3d  %s \t  ", pc-1, opcodesSIO[ir.m]);                    //printf("halting...\n");                    /*printf("%3d  %s\n", pc-1, opcodesSIO[ir.m]);   */     break;    default:     printf("SIO error\n");    }  // default  default:   //printf("exec error\n");      ; }  //printState(ir);}int halt(){   if(ir.op == 9 && ir.m == 2)      return 1;  if (pc >= codeSize)    return 1;  if(pc == MAX_CODE_LENGTH)    return 1;   return 0;}int base(int level, int b){   while(level>0){      b = stack[b+1];      level--;   }   return b;}/**bp>1  write_Stack(output_file, stack[bp+2], bp-1};bp<sp  print |  printstackelsebp<spprintStack**/
